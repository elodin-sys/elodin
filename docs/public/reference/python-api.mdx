---
title: Python API
icon: python
---

## Systems

Systems are the building blocks of simulation; they are functions that operate on a set of input components and produce a set of output components. Elodin provides decorators that allow for systems to be easily defined from functions.

### `@elodin.system`

<Note>
This is a lower-level primitive; for many cases `@elodin.map` – a wrapper around `@elodin.system` – is easier to use.
</Note>

This is a lower-level API for defining a system. A function decorated with `@elodin.system` accepts special parameter types (such as [elodin.Query] and [elodin.GraphQuery]) that specify what data the system needs access to. It returns an [elodin.Query] containing one or more [components]. Some examples of `@elodin.system` are:

```python
import elodin as el

@el.system
def gravity(
    graph: el.GraphQuery[GravityEdge],
    query: el.Query[el.WorldPos, el.Inertia],
) -> el.Query[el.Force]: ...

@el.system
def apply_wind(
    w: el.Query[Wind], q: el.Query[el.Force, el.WorldVel]
) -> el.Query[el.Force]: ...
```

### `@elodin.map`

<Note>
Graph queries cannot be used with `@elodin.map`. Use `@elodin.system` instead.
</Note>

This is a higher-level API for defining a system that reduces the boilerplate of `@elodin.system` by unpacking the input and output queries into individual components, and wrapping the body of the function in a `query.map(ret_ty, ...)` call. It is useful for systems with simple data flow patterns. Some examples of `@elodin.map` are:

```python
import elodin as el

@el.map
def gravity(f: el.Force, inertia: el.Inertia) -> el.Force: ...

@el.map
def gyro_omega(vel: el.WorldVel) -> GyroOmega: ...
```

The following systems are equivalent as the `@elodin.map` definition effectively desugars to the `@elodin.system` one:

```python
import elodin as el

@el.map
def gravity(f: el.Force, inertia: el.Inertia) -> el.Force:
    return f + el.SpatialForce.from_linear(inertia.mass() * jnp.array([0.0, -9.81, 0.0]))

@el.system
def gravity(query: el.Query[el.Force, el.Inertia]) -> el.Query[el.Force]:
    return query.map(
        el.Force,
        lambda f, inertia: f + el.SpatialForce.from_linear(inertia.mass() * jnp.array([0.0, -9.81, 0.0])),
    )
```

### `elodin.Query`

`Query` is the primary mechanism for accessing data in Elodin. It is a view into the world state that is filtered by the components specified in the query. Only entities that have been spawned with all of the query's components will be selected for processing. For example, the query `Query[WorldPos, Inertia]` would only select entities that have both a `WorldPos` and an `Inertia` component (typically via the `Body` [archetype](#archetypes)).

- `map(ret_ty, map_fn)` -> [elodin.Query]

    Apply a function `map_fn` to the query's components and return a new query with the specified `ret_ty` return type. `map_fn` should be a function that takes the query's components as arguments and returns a single value of type `ret_ty`.

    ```python
    import elodin as el

    @el.system
    def gravity(query: el.Query[el.Force, el.Inertia]) -> el.Query[el.Force]:
        return query.map(
            el.Force,
            lambda f, inertia: f + el.SpatialForce.from_linear(inertia.mass() * jnp.array([0.0, -9.81, 0.0])),
        )
    ```

    In this example, `ret_ty` is `el.Force` and `map_fn` is a lambda function with the signature `(el.Force, el.Inertia) -> el.Force`.


    To return multiple components as output, `ret_ty` must be a tuple:
    ```python
    import elodin as el

    @el.system
    def multi_out_sys(query: el.Query[A]) -> el.Query[C, D]:
        return query.map(tuple[C, D], lambda a: ...)
    ```

## Primitives

### _class_ `elodin.Quaternion`

Unit quaternions are used to represent spatial orientations and rotations of bodies in 3D space.

- `Quaternion.identity()` -> [elodin.Quaternion]

    Create a unit quaternion with no rotation.

- `Quaternion.from_axis_angle()` -> [elodin.Quaternion]

    Create a quaternion from an axis and an angle.

- `inverse()` -> [elodin.Quaternion]

    Compute the inverse of the quaternion.

- `normalize()` -> [elodin.Quaternion]

    Normalize to a unit quaternion.

- `__add__(other)` -> [elodin.Quaternion]

    Add two quaternions.

    <Info>
    Adding quaternions does not yield the composite rotation unless they are [infinitesimal rotations](https://en.wikipedia.org/wiki/Rotation_matrix#Infinitesimal_rotations). Use multiplication instead.
    </Info>

- `__mul__(other)` -> [elodin.Quaternion]

    Multiply two quaternions.

- `__matmul__(vector)` -> [jax.Array]

    Rotate `vector` by computing the matrix product. The vector can be a plain [jax.Array] or one of the following spatial objects: [elodin.SpatialTransform], [elodin.SpatialMotion], [elodin.SpatialForce].


## Spatial Vector Algebra

Elodin uses Featherstone’s spatial vector algebra notation for rigid-body dynamics as it is a compact way of representing the state of a rigid body with six degrees of freedom. You can read a short into [here](https://homes.cs.washington.edu/~todorov/courses/amath533/FeatherstoneSlides.pdf) or in [Rigid Body Dynamics Algorithms (Featherstone - 2008)](https://link.springer.com/book/10.1007/978-1-4899-7560-7).

### _class_ `elodin.SpatialTransform`

A spatial transform is a 7D vector that represents a rigid body transformation in 3D space.

- `SpatialTransform.zero()` -> [elodin.SpatialTransform]

    Create a spatial transform with no rotation or translation.

- `SpatialTransform.from_linear(linear)` -> [elodin.SpatialTransform]

    Create a spatial transform from a linear vector.

- `SpatialTransform.from_angular(quaternion)` -> [elodin.SpatialTransform]

    Create a spatial transform from a quaternion.

- `linear()` -> [jax.Array]

    Get the linear part of the spatial transform as a vector with shape (3,).

- `angular()` -> [elodin.Quaternion]

    Get the angular part of the spatial transform as a quaternion.

- `__add__(other)` -> [elodin.SpatialTransform]

    Add two spatial transforms.

### _class_ `elodin.SpatialMotion`

A spatial motion is a 6D vector that represents the velocity of a rigid body in 3D space.

- `SpatialMotion.zero()` -> [elodin.SpatialMotion]

    Create a spatial motion with no linear or angular velocity.

- `SpatialMotion.from_linear(linear)` -> [elodin.SpatialMotion]

    Create a spatial motion from a linear vector.

- `SpatialMotion.from_angular(angular)` -> [elodin.SpatialMotion]

    Create a spatial motion from an angular vector.

- `linear()` -> [jax.Array]

    Get the linear part of the spatial motion as a vector with shape (3,).

- `angular()` -> [jax.Array]

    Get the angular part of the spatial motion as a vector with shape (3,).

- `__add__(other)` -> [elodin.SpatialMotion]

    Add two spatial motions.

### _class_ `elodin.SpatialForce`

A spatial force is a 6D vector that represents the linear force and torque applied to a rigid body in 3D space.

- `SpatialForce.zero()` -> [elodin.SpatialForce]

    Create a spatial force with no linear force or torque.

- `SpatialForce.from_linear(linear)` -> [elodin.SpatialForce]

    Create a spatial force from a linear force vector.

- `SpatialForce.from_torque(angular)` -> [elodin.SpatialForce]

    Create a spatial force from a torque vector.

- `force()` -> [jax.Array]

    Get the linear force part of the spatial force as a vector with shape (3,).

- `torque()` -> [jax.Array]

    Get the torque part of the spatial force as a vector with shape (3,).

- `__add__(other)` -> [elodin.SpatialForce]

    Add two spatial forces.

### _class_ `elodin.SpatialInertia`

A spatial inertia is a 7D vector that represents the mass, moment of inertia, and momentum of a rigid body in 3D space. The moment of inertia is represented in its [diagonalized form] of $[I_1, I_2, I_3]$.

[diagonalized form]: https://en.wikipedia.org/wiki/Moment_of_inertia#Principal_axes

- `__init__(mass, inertia)` -> [elodin.SpatialInertia]

    Create a spatial tensor inertia from a scalar mass and an optional inertia tensor diagonal with shape (3,). If the inertia tensor is not provided, it is set to the same value as the mass along all axes.

- `mass()` -> [jax.Array]

    Get the scalar mass of the spatial inertia.

- `inertia_diag()` -> [jax.Array]

    Get the inertia tensor diagonal of the spatial inertia with shape (3,).

[Components]: #components

[elodin.Query]: #elodin-query
[elodin.GraphQuery]: #elodin-graphquery

[elodin.Quaternion]: #class-elodin-quaternion
[elodin.SpatialTransform]: #class-elodin-spatialtransform
[elodin.SpatialMotion]: #class-elodin-spatialmotion
[elodin.SpatialForce]: #class-elodin-spatialforce
[elodin.SpatialInertia]: #class-elodin-spatialinertia
[jax.Array]: https://jax.readthedocs.io/en/latest/_autosummary/jax.Array.html#jax.Array
[jax.typing.ArrayLike]: https://jax.readthedocs.io/en/latest/_autosummary/jax.typing.ArrayLike.html#jax.typing.ArrayLike
